-- DDL (데이터 정의어) :  Data Definition Language ; 데이터와 그 구조를 정의
-- CREATE : 데이터 베이스 객체 생성
-- DROP : 데이터 베이스 객체를 삭제
-- ALTER : 기존에 존재하는 데이터베이스 객체를 다시 정의

-- 1. 테이블 만들기 (CREATE)

CREATE TABLE EMP01 (
    EMPNO NUMBER(4),
    ENAME VARCHAR2(20),
    SAL NUMBER(7,2)
    );
    
-- 책의 정보를 저장하는 테이블 생성합니다.
-- BOOK TABLE : BOOKID(도서번호) NUMBER : BOOKNAME (도서이름) 문자(20) : PUBLISHER (출판사) 문자 30 : PRICE(가격) : NUMBER
-- PUBLISING_DATE (출판일) : DATE

CREATE TABLE BOOK (
    BOOKID NUMBER, -- 도서번호
    BOOKNAME VARCHAR2(20), -- 도서이름
    PUBLISHER VARCHAR2(30), -- 출판사
    PRICE NUMBER, -- 가격
    PBLISING_DATE DATE -- 출판일
);

SELECT * FROM BOOK;

CREATE TABLE BOOK ( -- 다른 객체 (테이블, VIEW, 제약조건) 이름이 있으면 그 이름 사용불가.
    BOOKID VARCHAR2(10), -- 도서번호
    BOOKNAME VARCHAR2(20), -- 도서이름
    PUBLISHER VARCHAR2(30), -- 출판사
    PRICE NUMBER, -- 가격
    PBLISING_DATE DATE -- 출판일
);


-- DEPT TABLE  같은 구조의 테이블을 DEPTNO 로 생성한다.

DESC DEPT;

CREATE TABLE DEPTNO (
    DEPTNO NUMBER(2, 0),
    DNAME VARCHAR2(14),
    LOC VARCHAR2(13)
);

SELECT * FROM DEPTNO;

-- EMP TABLE 과 같은 구조와 같은 데이터가 들어있는 테이블 EMP01 을 생성한다.
DROP TABLE EMP01; --  테이블 제거

CREATE TABLE EMP01
    AS
    SELECT * FROM EMP; -- TABLE 복사. : CREATE 문에서 쓰는 SUBQUERY. AS 뒤에 온다.
    
SELECT * FROM EMP01; --서브쿼리를 이용해서 테이블을 작성하면 구조와 데이터를 한꺼번에 옮김. 제약조건은 복사되지 않음

DESC EMP;
DESC EMP01;

-- EMP TABLE 의 EMPNO, ENAME 만 복사하는 EMP02  테이블을 생성한다.
CREATE TABLE EMP02
AS
SELECT EMPNO, ENAME FROM EMP;

DESC EMP02;
SELECT * FROM EMP02;

-- EMP 테이블의 부서번호가 10번인 데이터중 EMPNO, ENAME, SAL 만 복사하는 EMP03 테이블 생성
CREATE TABLE EMP03
AS
SELECT EMPNO, ENAME, SAL FROM EMP WHERE DEPTNO =10;

DESC EMP03;
SELECT * FROM EMP03;

-- EMP  TABLE의 구조만 복사하는 EMP04 생성(데이터는 가져오지 않음)
CREATE TABLE EMP04
AS
SELECT * FROM EMP WHERE 1 = 0; -- 데이터는 복사되지 않음. (WHERE 조건이 항상 거짓이기 때문에 출력물이 없고 구조만 불러옴.)

-- 2. 테이블의 구조를 변경하기. (ALTER TABLE)
-- 기존의 테이블 필드 추가하기

SELECT * FROM EMP02;
ALTER TABLE EMP02 ADD(JOB VARCHAR2(20)); 

SELECT * FROM EMP04;
ALTER TABLE EMP04 ADD(LOC VARCHAR2(20));

-- 기존의 테이블의 필드의 데이터 타입및 제약조건 변경.
DESC EMP02;
ALTER TABLE EMP02 MODIFY(ENAME VARCHAR2(30)); -- 구조변경
ALTER TABLE EMP02 MODIFY(ENAME VARCHAR2(2)); -- 구조변경불가 (데이터가 있다면 해당 부분을 참조해서 변경되어야 한다.)

DESC EMP04;
ALTER TABLE EMP04 MODIFY(LOC NUMBER);

DESC DEPT01;
ALTER TABLE DEPT01 MODIFY(DEPTNO NUMBER(3));

-- 기존의 테이블의 필드를 삭제하기.
SELECT * FROM EMP01;

ALTER TABLE EMP01 DROP COLUMN SAL; -- 물리적으로 SAL 필드를 삭제.

ALTER TABLE EMP01 ADD(SAL NUMBER(7,2));

-- 논리적으로 JOB 필드를 삭제합니다.
ALTER TABLE EMP01 SET UNUSED(JOB); -- 논리적으로 JOB 필드를 삭제합니다.

-- 논리적으로 삭제한것을 처리 (물리적으로 삭제를 확정.)
ALTER TABLE EMP01 DROP UNUSED COLUMNS;

SELECT * FROM EMP01;

--3. 테이블을 제거. (DROP TABLE)
DROP TABLE EMP04;

DROP TABLE BOOK;
CREATE TABLE BOOK(
    ID VARCHAR2(10),
    TITLE VARCHAR2(100)
); -- 삭제를 하고 만들면 반드시 만들게 된다.

-- 4 테이블의 이름을 변경.
RENAME EMP02 TO NEW_EMP02; -- EMP02 테이블 이름이 NEW_EMP02 로

SELECT * FROM NEW_EMP02;

-- 5 테이블 내 모든 데이터를 삭제하는  DDL
TRUNCATE TABLE NEW_EMP02; -- 복구 불가능.

SELECT * FROM NEW_EMP02;

-- 6 데이터 딕셔너리 VS 데이터 딕셔너리 뷰. (DBA_XXXX , ALL_XXX , USER_ XXXX)

SELECT * FROM DBA_TABLES; -- DBA 권한 테이블을 모두 보여줌

SELECT * FROM USER_TABLES; -- USER 권한 테이블을 모두 보여줌

SELECT * FROM ALL_TABLES; -- 자신이 소유, 자신의 권한이 있는 테이블을 모두 보여줌.

SELECT * FROM USER_CONSTRAINTS; -- 자신이 소유하고 있는 제약조건.

SELECT * FROM USER_VIEWS; -- 자신이 소유한 VIEW 를 보여준다.

SELECT * FROM USER_INDEXES; --자신이 소유하고 있는 INDEX정보.

DESC USER_TABLES;

-- DML (데이터 조작어)  :  Data Manipulation Language ; 데이터를 추가(INSERT), 삭제(DELETE) 수정(UPDATE) 검색(SELECT) 등
-- INSERT : 데이터베이스 객체에 데이터를 입력
-- 문법 : (1) INSERT INTO table_name (column_name, ..) VALUES (column_values, …);
CREATE TABLE DEPT01
AS
SELECT * FROM DEPT WHERE 0 = 1; 

-- DEPTNO(10) DNAME('ACCOUNTING') LOC('NEW YORK') 행 추가.
INSERT INTO DEPT01 (DEPTNO, DNAME, LOC) VALUES (10, 'ACCOUNTING', 'NEW YORK');

INSERT INTO DEPT01 (LOC, DNAME, DEPTNO) VALUES ('SEOUL', 'IT', 20);

INSERT INTO DEPT01 (DEPTNO, DNAME, LOC) VALUES (10, 'SALES', NULL); -- 값으로 NULL 을 넣을수 있음.

INSERT INTO DEPT01 (DEPTNO, DNAME) VALUES (40, 'INSA'); -- 명시하지 않은 필드는 자동으로 NULL 값이 들어감.

INSERT INTO DEPT01 VALUES (50, 'MARKER', NULL); -- 모든 필드의 값을 넣어야 에러가 나지 않는다. 

COMMIT; -- 모든 DML 명령을 DBMS 에 적용함.

ROLLBACK; -- 데이터 입력 취소 가능. (최후로 커밋 하기 전까지 돌아감.)

TRUNCATE TABLE EMP01;
COMMIT; ----------------------- 최후의 커밋 지점

INSERT INTO EMP01 (EMPNO, ENAME, SAL) VALUES (1111, '홍', 1000);

SAVEPOINT AA; -- AA지점

INSERT INTO EMP01 (EMPNO, ENAME, SAL) VALUES (2222, '박', 2000);

SAVEPOINT BB; -- BB지점

INSERT INTO EMP01 (EMPNO, ENAME, SAL) VALUES (3333, '유', 3000);

ROLLBACK TO BB; -- 세이브 포인트 지점 BB 으로 돌아감.

ROLLBACK TO AA; -- 세이브 포인트 지점 AA 으로 돌아감.

ROLLBACK; -- 최후의 COMMIT 지점으로 돌아감.

SELECT * FROM  EMP01;

COMMIT; -- 최후의 COMMIT 지점부터의 DML 명령어가 오라클에 적용.

DROP TABLE SAM01;
CREATE TABLE SAM01 (
    EMPNO NUMBER(4),
    ENAME VARCHAR2(20),
    JOB VARCHAR2(15),
    SAL NUMBER(7)
);

DESC SAM01;

INSERT INTO SAM01 VALUES (1000, 'APPLE', 'POLICE', 10000);
INSERT INTO SAM01 VALUES (1010, 'BANANA', 'NURSE', 15000);
INSERT INTO SAM01 VALUES (1020, 'ORENGE', 'DOCTOR', 25000);
INSERT INTO SAM01 VALUES (1030, 'VERY', NULL, 25000);
INSERT INTO SAM01 VALUES (1040, 'CAT', NULL, 2000);

COMMIT;

-- 10번 부서에 속한 사람들의 데이터의 사번, 이름, 업무, 급여를 SAM01 에 넣는다.
INSERT INTO SAM01 (SELECT EMPNO, ENAME, JOB, SAL FROM EMP WHERE DEPTNO = 10); -- 서브쿼리 이용  INSERT INTO

SELECT EMPNO, ENAME, JOB, SAL FROM EMP WHERE DEPTNO = 10; -- SUBQUERY

SELECT * FROM SAM01;

-- EX> 도서를 저장 : TABLE BOOK(BOOKNAME, BOOKID, PUBLISHER, PRICE) (도서의 이름 : 스포츠 의학, 도서ID : 11, 출판사 : 한솔의학서적, 가격 : 90000)
DROP TABLE BOOK;
CREATE TABLE BOOK (
    BOOKID NUMBER(3),
    BOOKNAME VARCHAR2(30),
    PUBLISHER VARCHAR(30),
    PRICE NUMBER(6)
);

INSERT INTO BOOK (BOOKID, BOOKNAME,  PUBLISHER, PRICE) VALUES (11, '스포츠 의학', '한솔의학서적', 90000);
COMMIT;

SELECT * FROM BOOK;

--(2) 데이터 수정 : UPDATE 테이블명 SET 수정하고자 하는 필드 = 수정하고자 하는 값
-- 수정과 삭제는 WHERE 절을 거의 반드시 사용하게 된다. 


DROP TABLE EMP01;
CREATE TABLE EMP01 AS SELECT * FROM EMP;

-- 수정조건이 없는 경우
UPDATE EMP01 SET SAL = SAL*1.1;

-- 수정 조건이 있는 경우. ENAME = SMITH
-- SMITH 가 부서를 30번 부서로 옮기고 SAL 1000 으로 인상. MANAGER 상사의 사번 7839
UPDATE EMP01 SET DEPTNO = 30, SAL = 1000, JOB = 'MANAGER', MGR = 7839 WHERE ENAME = 'SMITH'; 

-- EMP01 테이블에서 SAL이 3000 이상인 사원만 SAL 을 10% 인상합니다.
UPDATE EMP01 SET SAL = SAL * 1.1 WHERE SAL >= 3000;

COMMIT;

-- EMP01 테이블에서 DALLAS 에 근무하는 직원들의 연봉을 1000씩 인상합니다. (영구적으로DB 에 반영.)
UPDATE EMP01 SET SAL = SAL+1000 WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE LOC = 'DALLAS');

COMMIT;

-- 20번 부서의 지역명, 부서명을 40번 부서의 지역명으로 부서명으로 변경하는 UPDATE 문을 작성.
UPDATE DEPT01 SET (DNAME, LOC) = (SELECT DNAME, LOC FROM DEPT01 WHERE DEPTNO = 40)
WHERE DEPTNO = 20;

COMMIT;

SELECT * FROM DEPT01;

-- EMP01 의 모든 직원을 'KING' 의 사원의 급여와 입사일로 변경하세요.
UPDATE EMP01 SET (SAL, HIREDATE) = (SELECT SAL, HIREDATE FROM EMP01 WHERE ENAME = 'KING');

COMMIT;

-- 수정될 조건이 없는 UPDATE 문.
UPDATE EMP01 SET SAL = 9999, HIREDATE = SYSDATE WHERE ENAME = '홍길동'; -- 수정될 조건이 없다면 0행 업데이트. (문법에는 맞지만 결과는 없다.)

SELECT * FROM EMP01;
--(3) DELETE : 데이터베이스 객체에 데이터를 삭제. : DELETE FROM TABLE명 WHERE 조건

SELECT * FROM DEPT01;

DELETE FROM DEPT01; -- 테이블의 모든 데이터 삭제하는  DML언어
TRUNCATE TABLE DEPT01; --테이블의 모든 데이터 삭제. DDL 언어

ROLLBACK; -- 오직 DML 인 DELETE나 UPDATE INSERT 에만 작동한다.

-- EMP01 테이블에서 30번 부서의 직원만 삭제합니다.
SELECT * FROM EMP01;

DELETE FROM EMP01 WHERE DEPTNO = 30;

-- EMP01 테이블에서 SMITH 직원을 퇴사하세요.
DELETE FROM EMP01 WHERE ENAME = 'SMITH';

-- EMP01 테이블에서 부서명이 SALES 인 사원을 삭제합니다.
DELETE FROM EMP01 WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE DNAME = 'SALES');

-- SAM01 테이블에서 JOB 이 정해져있지 않는 직원은 삭제합니다.
DELETE FROM SAM01 WHERE JOB IS NULL; -- NULL  은 연산조건을 IS 로 ...

SELECT* FROM SAM01;

--8. 제약조건 : 테이블에 부적합한 데이터는 입력되는 것을 방지 하는게 목적.
DROP TABLE DEPT1;
CREATE TABLE DEPT1(
    DEPTNO NUMBER(2), -- 주키로 지정.
    DNAME VARCHAR2(14) NOT NULL, -- NULL 값이 올수 없는 필드로 지정.
    LOC VARCHAR2(13) NOT NULL, -- NULL 값이 올수 없는 필드로 지정.
    CONSTRAINT DEPT1_C0 PRIMARY KEY(DEPTNO),
    CONSTRAINT DEPT1_C1 UNIQUE(DNAME));

SELECT * FROM USER_CONSTRAINTS WHERE CONSTRAINT_NAME LIKE '%EMP1%';
SELECT * FROM USER_CONSTRAINTS WHERE CONSTRAINT_NAME LIKE '%DEPT1%';

DROP TABLE EMP1;
CREATE TABLE EMP1(
    EMPNO NUMBER(4),
    ENAME VARCHAR2(10) NOT NULL,
    JOB VARCHAR2(9),
    MGR NUMBER(4),
    HIREDATE DATE DEFAULT SYSDATE, -- 입력되는 순간의 시간을 입력.
    SAL NUMBER(7,2) CHECK(SAL > 0), -- 입력제약조건을 만족해야 입력됨.
    COMM NUMBER(7,2),
    DEPTNO NUMBER(2), -- DEPT1 테이블의 DEPTNO 값으로 있는 값만 입력되도록 제약.
    CONSTRAINT EMP1_C0 PRIMARY KEY(EMPNO),
    CONSTRAINT EMP1_C1 FOREIGN KEY(DEPTNO) REFERENCES DEPT1(DEPTNO)
);

SELECT * FROM DEPT1;
SELECT * FROM EMP1;

INSERT INTO DEPT1 VALUES (10, 'ACCOUNTING', 'NEW YORK');
INSERT INTO DEPT1 VALUES (20, 'RESERACH', 'DALLAS');
INSERT INTO DEPT1 VALUES (30, 'SALES', 'CHICAGO');
INSERT INTO DEPT1 VALUES (40, 'OPERATION', 'BOSTON');

INSERT INTO DEPT1 VALUES (SELECT * FROM DEPT); -- 데이터를 복사.
COMMIT;

INSERT INTO EMP1 (EMPNO, ENAME, DEPTNO) VALUES (1111, '홍', 10);
INSERT INTO EMP1 (EMPNO, ENAME, DEPTNO, SAL) VALUES (2222, 'KIM', 20, 0);

-- ex> 책관리 데이터 베이스 TABLE 을 생성하고 데이터를 넣어보자.
DROP TABLE BOOKKIND;
CREATE TABLE BOOKKIND (
    BOOKCODE NUMBER(3),
    BOOKKIND VARCHAR2(30) NOT NULL,
    LOC VARCHAR2(50),
    PRIMARY KEY(BOOKCODE),
    UNIQUE(BOOKKIND)
);


DROP TABLE BOOK;
CREATE TABLE BOOK (
    BOOKID VARCHAR2(10),
    BOOKCODE NUMBER(3) NOT NULL,
    BOOKNAME VARCHAR2(30) NOT NULL,
    PUBLISHER VARCHAR2(100) NOT NULL,
    PUBYEAR DATE DEFAULT SYSDATE,
    PRIMARY KEY(BOOKID),
    FOREIGN KEY(BOOKCODE) REFERENCES BOOKKIND(BOOKCODE)
);

SELECT * FROM BOOKKIND;
SELECT * FROM BOOK;

-- BOOKKIND 입력
INSERT INTO BOOKKIND (BOOKCODE, BOOKKIND, LOC) VALUES (100, '철학', '3층 인문실');
INSERT INTO BOOKKIND (BOOKCODE, BOOKKIND, LOC) VALUES (200, '인문', '3층 인문실');
INSERT INTO BOOKKIND (BOOKCODE, BOOKKIND, LOC) VALUES (300, '자연과학', '4층 과학실');
INSERT INTO BOOKKIND (BOOKCODE, BOOKKIND, LOC) VALUES (400, 'IT', '4층 과학실');

-- BOOK 입력
INSERT INTO BOOK (BOOKID, BOOKCODE, BOOKNAME, PUBLISHER, PUBYEAR) VALUES ('100A01', 100, '철학자의 삶', '더존출판', SYSDATE);
INSERT INTO BOOK (BOOKID, BOOKCODE, BOOKNAME, PUBLISHER, PUBYEAR) VALUES ('100A02', 200, '이것이 자바다', '더존출판', SYSDATE);

COMMIT;


-- DCL (데이터 제어어) : 사용자를 만들기, 사용자를 제거. 사용자 권한부여, 사용자 권한 박탈.

